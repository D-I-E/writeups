# Writeup

1. 执行file命令，分析结果为32位ELF文件。

```
$ file oldtimes 
oldtimes: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=fd699ac1d63ac81afca3155011beeb2b91f974a3, stripped
```

2. 用ida导入文件并利用f5反编译分析程序逻辑，发现一处64字节输入经0x08048B03，0x0804875A，0x08048AEC三个函数处理即可到达正确输出位置。

```
LOBYTE(v1) = sub_8048B03(&v15, &v15, &s, 64, &unk_804A420);
if ( v1 )
{
  puts("Incorrect.");
  result = 0;
}
else
{
  sub_804875A(&v14, &v15, &unk_804A1A0, &unk_804A060, 0x140u);
  if ( sub_8048AEC(&v4 == 0, &v14, &unk_804A2E0, 320) )
  {
    puts("Correct.\nCongratulations!");
    result = 0;
  }
  else
  {
    puts("Incorrect.");
    result = 0;
  }
  }
```

3. 0x08048B03处函数分析，发现是将输入字符串经过一次映射并扩充至最多64个字节的数组并返回，数组表示一个十进制数。

4. 0x0804875A处函数分析，发现是快速幂取模的汇编代码，输入是0x08048B03结果以及两个定值，输出是快速幂取模的结果。其中0x08048AD8处函数是判断数组表示的十进制数是否为0，0x08048AB3处函数是取数组表示的十进制数最低bit的值，0x08048612处函数是计算两数乘积并将结果对0x0804A060处定值取模。在0x08048612处函数中，0x08048A70处函数是计算两数之和并将结果对0x0804A060处定值取模。

5. 0x08048AEC处函数分析，发现是判断0x0804875A输出结果与给定数组0x0804A2E0做比较。

6. 因此可以抽象成如下代码，其中x未知，a，e，n已知。其形式与rsa加密／解密一致，通过查阅flappypig关于rsa的文章，发现可以利用Wiener Attack分解n，从而计算另一密钥解出x，进而根据映射计算flag。

```python
if (x**e) % n == a:
    print 'Correct'
else:
    print 'Incorrect'
```

# Exp

```python
from RSAwienerHacker import *

e = 65326441199468453286318255077403579659791312164553127869260446442105779909064937488537560101781375987673235379770584320200902922242466357110710512224365096172037200923774406729082247857808967592679310852236885503191205805867846536002124193676637708886499398965506519247168289750006311551455779911863709319947

n = 106491733927966194442570111833195971964540708710920248828539833058388088046807126527055336225402088921783018876076946794272419044969606936676842530973101509230963945247110105556900247885580601951941082462702181710167276943785261576473507495128333901938830998211916498162015185298755857306262703571421288351501

a = 33622269493924708607616624997424398912036927135599622278786063601678887543600400094409392433011134767526461813770729744913267138041445567265417022865204844947994077429853354378479239765411140344806650450747715214836133182538012671115882981194344900010564346012743782146937616191257888190694561289344531933844

d = hack_RSA(e, n)

def mul(x, y, z):
    ret = 1
    while y > 0:
        if y & 1:
            ret = (ret * x) % z
        x = (x * x) % z
        y >>= 1
    return ret

str_map = map(ord, '00FFFFFFFFFFFFFFFF2E002F133EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3C5737624E474A404B03115F0E0B3546535A163849450D325D43612A1F282609274D083D5522440134562D480A0C421E30204C103F2B0729064F1733391B12193B05043A18516352151C5B1A251D212C545E506024025C58413631230F5914FF'.decode('hex'))

plain = str(mul(a, d, n))

ans = ''

for i in range(0, len(plain), 2):
    tmp = int(plain[i]+plain[i+1], 10)
    ans += chr(str_map.index(tmp))

print ans[::-1]
```

# Other writeups and resources

1. [CTF中RSA的常见攻击方法](http://bobao.360.cn/learning/detail/3058.html)
2. [wiener attack](https://github.com/pablocelayes/rsa-wiener-attack)